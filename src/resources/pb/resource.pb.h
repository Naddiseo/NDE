// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/resources/pb/resource.proto

#ifndef PROTOBUF_src_2fresources_2fpb_2fresource_2eproto__INCLUDED
#define PROTOBUF_src_2fresources_2fpb_2fresource_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace nde {
namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();

class Vector3f;
class UV;
class Material;
class Face;
class UVMap;
class Mesh;
class Camera;
class Color;
class Assets;

// ===================================================================

class Vector3f : public ::google::protobuf::Message {
 public:
  Vector3f();
  virtual ~Vector3f();
  
  Vector3f(const Vector3f& from);
  
  inline Vector3f& operator=(const Vector3f& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3f& default_instance();
  
  void Swap(Vector3f* other);
  
  // implements Message ----------------------------------------------
  
  Vector3f* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3f& from);
  void MergeFrom(const Vector3f& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);
  
  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);
  
  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);
  
  // @@protoc_insertion_point(class_scope:nde.pb.Vector3f)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_;
  float y_;
  float z_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Vector3f* default_instance_;
};
// -------------------------------------------------------------------

class UV : public ::google::protobuf::Message {
 public:
  UV();
  virtual ~UV();
  
  UV(const UV& from);
  
  inline UV& operator=(const UV& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UV& default_instance();
  
  void Swap(UV* other);
  
  // implements Message ----------------------------------------------
  
  UV* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UV& from);
  void MergeFrom(const UV& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 vertex = 1;
  inline bool has_vertex() const;
  inline void clear_vertex();
  static const int kVertexFieldNumber = 1;
  inline ::google::protobuf::uint32 vertex() const;
  inline void set_vertex(::google::protobuf::uint32 value);
  
  // required float u = 2;
  inline bool has_u() const;
  inline void clear_u();
  static const int kUFieldNumber = 2;
  inline float u() const;
  inline void set_u(float value);
  
  // required float v = 3;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 3;
  inline float v() const;
  inline void set_v(float value);
  
  // @@protoc_insertion_point(class_scope:nde.pb.UV)
 private:
  inline void set_has_vertex();
  inline void clear_has_vertex();
  inline void set_has_u();
  inline void clear_has_u();
  inline void set_has_v();
  inline void clear_has_v();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 vertex_;
  float u_;
  float v_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static UV* default_instance_;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::Message {
 public:
  Material();
  virtual ~Material();
  
  Material(const Material& from);
  
  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Material& default_instance();
  
  void Swap(Material* other);
  
  // implements Message ----------------------------------------------
  
  Material* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional string file = 2;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 2;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const char* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  
  // @@protoc_insertion_point(class_scope:nde.pb.Material)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_file();
  inline void clear_has_file();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* file_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Material* default_instance_;
};
// -------------------------------------------------------------------

class Face : public ::google::protobuf::Message {
 public:
  Face();
  virtual ~Face();
  
  Face(const Face& from);
  
  inline Face& operator=(const Face& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Face& default_instance();
  
  void Swap(Face* other);
  
  // implements Message ----------------------------------------------
  
  Face* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Face& from);
  void MergeFrom(const Face& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 a = 1;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 1;
  inline ::google::protobuf::uint32 a() const;
  inline void set_a(::google::protobuf::uint32 value);
  
  // required uint32 b = 2;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 2;
  inline ::google::protobuf::uint32 b() const;
  inline void set_b(::google::protobuf::uint32 value);
  
  // required uint32 c = 3;
  inline bool has_c() const;
  inline void clear_c();
  static const int kCFieldNumber = 3;
  inline ::google::protobuf::uint32 c() const;
  inline void set_c(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:nde.pb.Face)
 private:
  inline void set_has_a();
  inline void clear_has_a();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_c();
  inline void clear_has_c();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 a_;
  ::google::protobuf::uint32 b_;
  ::google::protobuf::uint32 c_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Face* default_instance_;
};
// -------------------------------------------------------------------

class UVMap : public ::google::protobuf::Message {
 public:
  UVMap();
  virtual ~UVMap();
  
  UVMap(const UVMap& from);
  
  inline UVMap& operator=(const UVMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UVMap& default_instance();
  
  void Swap(UVMap* other);
  
  // implements Message ----------------------------------------------
  
  UVMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UVMap& from);
  void MergeFrom(const UVMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required uint32 material = 2;
  inline bool has_material() const;
  inline void clear_material();
  static const int kMaterialFieldNumber = 2;
  inline ::google::protobuf::uint32 material() const;
  inline void set_material(::google::protobuf::uint32 value);
  
  // required uint32 mesh = 3;
  inline bool has_mesh() const;
  inline void clear_mesh();
  static const int kMeshFieldNumber = 3;
  inline ::google::protobuf::uint32 mesh() const;
  inline void set_mesh(::google::protobuf::uint32 value);
  
  // repeated .nde.pb.UV coord = 4;
  inline int coord_size() const;
  inline void clear_coord();
  static const int kCoordFieldNumber = 4;
  inline const ::nde::pb::UV& coord(int index) const;
  inline ::nde::pb::UV* mutable_coord(int index);
  inline ::nde::pb::UV* add_coord();
  inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::UV >&
      coord() const;
  inline ::google::protobuf::RepeatedPtrField< ::nde::pb::UV >*
      mutable_coord();
  
  // @@protoc_insertion_point(class_scope:nde.pb.UVMap)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_material();
  inline void clear_has_material();
  inline void set_has_mesh();
  inline void clear_has_mesh();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 material_;
  ::google::protobuf::RepeatedPtrField< ::nde::pb::UV > coord_;
  ::google::protobuf::uint32 mesh_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static UVMap* default_instance_;
};
// -------------------------------------------------------------------

class Mesh : public ::google::protobuf::Message {
 public:
  Mesh();
  virtual ~Mesh();
  
  Mesh(const Mesh& from);
  
  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mesh& default_instance();
  
  void Swap(Mesh* other);
  
  // implements Message ----------------------------------------------
  
  Mesh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required .nde.pb.Vector3f position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::nde::pb::Vector3f& position() const;
  inline ::nde::pb::Vector3f* mutable_position();
  inline ::nde::pb::Vector3f* release_position();
  
  // required .nde.pb.Vector3f direction = 3;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 3;
  inline const ::nde::pb::Vector3f& direction() const;
  inline ::nde::pb::Vector3f* mutable_direction();
  inline ::nde::pb::Vector3f* release_direction();
  
  // repeated .nde.pb.Vector3f vertex = 4;
  inline int vertex_size() const;
  inline void clear_vertex();
  static const int kVertexFieldNumber = 4;
  inline const ::nde::pb::Vector3f& vertex(int index) const;
  inline ::nde::pb::Vector3f* mutable_vertex(int index);
  inline ::nde::pb::Vector3f* add_vertex();
  inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Vector3f >&
      vertex() const;
  inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Vector3f >*
      mutable_vertex();
  
  // repeated .nde.pb.Face face = 5;
  inline int face_size() const;
  inline void clear_face();
  static const int kFaceFieldNumber = 5;
  inline const ::nde::pb::Face& face(int index) const;
  inline ::nde::pb::Face* mutable_face(int index);
  inline ::nde::pb::Face* add_face();
  inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Face >&
      face() const;
  inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Face >*
      mutable_face();
  
  // @@protoc_insertion_point(class_scope:nde.pb.Mesh)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_direction();
  inline void clear_has_direction();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::nde::pb::Vector3f* position_;
  ::nde::pb::Vector3f* direction_;
  ::google::protobuf::RepeatedPtrField< ::nde::pb::Vector3f > vertex_;
  ::google::protobuf::RepeatedPtrField< ::nde::pb::Face > face_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Mesh* default_instance_;
};
// -------------------------------------------------------------------

class Camera : public ::google::protobuf::Message {
 public:
  Camera();
  virtual ~Camera();
  
  Camera(const Camera& from);
  
  inline Camera& operator=(const Camera& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Camera& default_instance();
  
  void Swap(Camera* other);
  
  // implements Message ----------------------------------------------
  
  Camera* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Camera& from);
  void MergeFrom(const Camera& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required .nde.pb.Vector3f position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::nde::pb::Vector3f& position() const;
  inline ::nde::pb::Vector3f* mutable_position();
  inline ::nde::pb::Vector3f* release_position();
  
  // required .nde.pb.Vector3f direction = 3;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 3;
  inline const ::nde::pb::Vector3f& direction() const;
  inline ::nde::pb::Vector3f* mutable_direction();
  inline ::nde::pb::Vector3f* release_direction();
  
  // @@protoc_insertion_point(class_scope:nde.pb.Camera)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_direction();
  inline void clear_has_direction();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::nde::pb::Vector3f* position_;
  ::nde::pb::Vector3f* direction_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Camera* default_instance_;
};
// -------------------------------------------------------------------

class Color : public ::google::protobuf::Message {
 public:
  Color();
  virtual ~Color();
  
  Color(const Color& from);
  
  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Color& default_instance();
  
  void Swap(Color* other);
  
  // implements Message ----------------------------------------------
  
  Color* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required float r = 3;
  inline bool has_r() const;
  inline void clear_r();
  static const int kRFieldNumber = 3;
  inline float r() const;
  inline void set_r(float value);
  
  // required float g = 4;
  inline bool has_g() const;
  inline void clear_g();
  static const int kGFieldNumber = 4;
  inline float g() const;
  inline void set_g(float value);
  
  // required float b = 5;
  inline bool has_b() const;
  inline void clear_b();
  static const int kBFieldNumber = 5;
  inline float b() const;
  inline void set_b(float value);
  
  // optional float a = 6;
  inline bool has_a() const;
  inline void clear_a();
  static const int kAFieldNumber = 6;
  inline float a() const;
  inline void set_a(float value);
  
  // @@protoc_insertion_point(class_scope:nde.pb.Color)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_r();
  inline void clear_has_r();
  inline void set_has_g();
  inline void clear_has_g();
  inline void set_has_b();
  inline void clear_has_b();
  inline void set_has_a();
  inline void clear_has_a();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  float r_;
  float g_;
  float b_;
  float a_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Color* default_instance_;
};
// -------------------------------------------------------------------

class Assets : public ::google::protobuf::Message {
 public:
  Assets();
  virtual ~Assets();
  
  Assets(const Assets& from);
  
  inline Assets& operator=(const Assets& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Assets& default_instance();
  
  void Swap(Assets* other);
  
  // implements Message ----------------------------------------------
  
  Assets* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Assets& from);
  void MergeFrom(const Assets& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .nde.pb.Material material = 2;
  inline int material_size() const;
  inline void clear_material();
  static const int kMaterialFieldNumber = 2;
  inline const ::nde::pb::Material& material(int index) const;
  inline ::nde::pb::Material* mutable_material(int index);
  inline ::nde::pb::Material* add_material();
  inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Material >&
      material() const;
  inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Material >*
      mutable_material();
  
  // repeated .nde.pb.UVMap uvmap = 3;
  inline int uvmap_size() const;
  inline void clear_uvmap();
  static const int kUvmapFieldNumber = 3;
  inline const ::nde::pb::UVMap& uvmap(int index) const;
  inline ::nde::pb::UVMap* mutable_uvmap(int index);
  inline ::nde::pb::UVMap* add_uvmap();
  inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::UVMap >&
      uvmap() const;
  inline ::google::protobuf::RepeatedPtrField< ::nde::pb::UVMap >*
      mutable_uvmap();
  
  // repeated .nde.pb.Mesh mesh = 4;
  inline int mesh_size() const;
  inline void clear_mesh();
  static const int kMeshFieldNumber = 4;
  inline const ::nde::pb::Mesh& mesh(int index) const;
  inline ::nde::pb::Mesh* mutable_mesh(int index);
  inline ::nde::pb::Mesh* add_mesh();
  inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Mesh >&
      mesh() const;
  inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Mesh >*
      mutable_mesh();
  
  // repeated .nde.pb.Camera camera = 5;
  inline int camera_size() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 5;
  inline const ::nde::pb::Camera& camera(int index) const;
  inline ::nde::pb::Camera* mutable_camera(int index);
  inline ::nde::pb::Camera* add_camera();
  inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Camera >&
      camera() const;
  inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Camera >*
      mutable_camera();
  
  // repeated .nde.pb.Color color = 6;
  inline int color_size() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline const ::nde::pb::Color& color(int index) const;
  inline ::nde::pb::Color* mutable_color(int index);
  inline ::nde::pb::Color* add_color();
  inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Color >&
      color() const;
  inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Color >*
      mutable_color();
  
  // @@protoc_insertion_point(class_scope:nde.pb.Assets)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::nde::pb::Material > material_;
  ::google::protobuf::RepeatedPtrField< ::nde::pb::UVMap > uvmap_;
  ::google::protobuf::RepeatedPtrField< ::nde::pb::Mesh > mesh_;
  ::google::protobuf::RepeatedPtrField< ::nde::pb::Camera > camera_;
  ::google::protobuf::RepeatedPtrField< ::nde::pb::Color > color_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_AssignDesc_src_2fresources_2fpb_2fresource_2eproto();
  friend void protobuf_ShutdownFile_src_2fresources_2fpb_2fresource_2eproto();
  
  void InitAsDefaultInstance();
  static Assets* default_instance_;
};
// ===================================================================


// ===================================================================

// Vector3f

// required float x = 1;
inline bool Vector3f::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3f::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3f::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3f::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3f::x() const {
  return x_;
}
inline void Vector3f::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Vector3f::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3f::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3f::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3f::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3f::y() const {
  return y_;
}
inline void Vector3f::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool Vector3f::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3f::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3f::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3f::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3f::z() const {
  return z_;
}
inline void Vector3f::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// UV

// required uint32 vertex = 1;
inline bool UV::has_vertex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UV::set_has_vertex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UV::clear_has_vertex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UV::clear_vertex() {
  vertex_ = 0u;
  clear_has_vertex();
}
inline ::google::protobuf::uint32 UV::vertex() const {
  return vertex_;
}
inline void UV::set_vertex(::google::protobuf::uint32 value) {
  set_has_vertex();
  vertex_ = value;
}

// required float u = 2;
inline bool UV::has_u() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UV::set_has_u() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UV::clear_has_u() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UV::clear_u() {
  u_ = 0;
  clear_has_u();
}
inline float UV::u() const {
  return u_;
}
inline void UV::set_u(float value) {
  set_has_u();
  u_ = value;
}

// required float v = 3;
inline bool UV::has_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UV::set_has_v() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UV::clear_has_v() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UV::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline float UV::v() const {
  return v_;
}
inline void UV::set_v(float value) {
  set_has_v();
  v_ = value;
}

// -------------------------------------------------------------------

// Material

// required uint32 id = 1;
inline bool Material::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Material::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Material::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Material::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Material::id() const {
  return id_;
}
inline void Material::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string file = 2;
inline bool Material::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Material::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Material::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Material::clear_file() {
  if (file_ != &::google::protobuf::internal::kEmptyString) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& Material::file() const {
  return *file_;
}
inline void Material::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void Material::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(value);
}
inline void Material::set_file(const char* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Material::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    file_ = new ::std::string;
  }
  return file_;
}
inline ::std::string* Material::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Face

// required uint32 a = 1;
inline bool Face::has_a() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Face::set_has_a() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Face::clear_has_a() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Face::clear_a() {
  a_ = 0u;
  clear_has_a();
}
inline ::google::protobuf::uint32 Face::a() const {
  return a_;
}
inline void Face::set_a(::google::protobuf::uint32 value) {
  set_has_a();
  a_ = value;
}

// required uint32 b = 2;
inline bool Face::has_b() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Face::set_has_b() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Face::clear_has_b() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Face::clear_b() {
  b_ = 0u;
  clear_has_b();
}
inline ::google::protobuf::uint32 Face::b() const {
  return b_;
}
inline void Face::set_b(::google::protobuf::uint32 value) {
  set_has_b();
  b_ = value;
}

// required uint32 c = 3;
inline bool Face::has_c() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Face::set_has_c() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Face::clear_has_c() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Face::clear_c() {
  c_ = 0u;
  clear_has_c();
}
inline ::google::protobuf::uint32 Face::c() const {
  return c_;
}
inline void Face::set_c(::google::protobuf::uint32 value) {
  set_has_c();
  c_ = value;
}

// -------------------------------------------------------------------

// UVMap

// required uint32 id = 1;
inline bool UVMap::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UVMap::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UVMap::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UVMap::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 UVMap::id() const {
  return id_;
}
inline void UVMap::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 material = 2;
inline bool UVMap::has_material() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UVMap::set_has_material() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UVMap::clear_has_material() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UVMap::clear_material() {
  material_ = 0u;
  clear_has_material();
}
inline ::google::protobuf::uint32 UVMap::material() const {
  return material_;
}
inline void UVMap::set_material(::google::protobuf::uint32 value) {
  set_has_material();
  material_ = value;
}

// required uint32 mesh = 3;
inline bool UVMap::has_mesh() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UVMap::set_has_mesh() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UVMap::clear_has_mesh() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UVMap::clear_mesh() {
  mesh_ = 0u;
  clear_has_mesh();
}
inline ::google::protobuf::uint32 UVMap::mesh() const {
  return mesh_;
}
inline void UVMap::set_mesh(::google::protobuf::uint32 value) {
  set_has_mesh();
  mesh_ = value;
}

// repeated .nde.pb.UV coord = 4;
inline int UVMap::coord_size() const {
  return coord_.size();
}
inline void UVMap::clear_coord() {
  coord_.Clear();
}
inline const ::nde::pb::UV& UVMap::coord(int index) const {
  return coord_.Get(index);
}
inline ::nde::pb::UV* UVMap::mutable_coord(int index) {
  return coord_.Mutable(index);
}
inline ::nde::pb::UV* UVMap::add_coord() {
  return coord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::UV >&
UVMap::coord() const {
  return coord_;
}
inline ::google::protobuf::RepeatedPtrField< ::nde::pb::UV >*
UVMap::mutable_coord() {
  return &coord_;
}

// -------------------------------------------------------------------

// Mesh

// required uint32 id = 1;
inline bool Mesh::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mesh::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mesh::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mesh::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Mesh::id() const {
  return id_;
}
inline void Mesh::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required .nde.pb.Vector3f position = 2;
inline bool Mesh::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mesh::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mesh::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mesh::clear_position() {
  if (position_ != NULL) position_->::nde::pb::Vector3f::Clear();
  clear_has_position();
}
inline const ::nde::pb::Vector3f& Mesh::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::nde::pb::Vector3f* Mesh::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::nde::pb::Vector3f;
  return position_;
}
inline ::nde::pb::Vector3f* Mesh::release_position() {
  clear_has_position();
  ::nde::pb::Vector3f* temp = position_;
  position_ = NULL;
  return temp;
}

// required .nde.pb.Vector3f direction = 3;
inline bool Mesh::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mesh::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mesh::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mesh::clear_direction() {
  if (direction_ != NULL) direction_->::nde::pb::Vector3f::Clear();
  clear_has_direction();
}
inline const ::nde::pb::Vector3f& Mesh::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::nde::pb::Vector3f* Mesh::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::nde::pb::Vector3f;
  return direction_;
}
inline ::nde::pb::Vector3f* Mesh::release_direction() {
  clear_has_direction();
  ::nde::pb::Vector3f* temp = direction_;
  direction_ = NULL;
  return temp;
}

// repeated .nde.pb.Vector3f vertex = 4;
inline int Mesh::vertex_size() const {
  return vertex_.size();
}
inline void Mesh::clear_vertex() {
  vertex_.Clear();
}
inline const ::nde::pb::Vector3f& Mesh::vertex(int index) const {
  return vertex_.Get(index);
}
inline ::nde::pb::Vector3f* Mesh::mutable_vertex(int index) {
  return vertex_.Mutable(index);
}
inline ::nde::pb::Vector3f* Mesh::add_vertex() {
  return vertex_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Vector3f >&
Mesh::vertex() const {
  return vertex_;
}
inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Vector3f >*
Mesh::mutable_vertex() {
  return &vertex_;
}

// repeated .nde.pb.Face face = 5;
inline int Mesh::face_size() const {
  return face_.size();
}
inline void Mesh::clear_face() {
  face_.Clear();
}
inline const ::nde::pb::Face& Mesh::face(int index) const {
  return face_.Get(index);
}
inline ::nde::pb::Face* Mesh::mutable_face(int index) {
  return face_.Mutable(index);
}
inline ::nde::pb::Face* Mesh::add_face() {
  return face_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Face >&
Mesh::face() const {
  return face_;
}
inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Face >*
Mesh::mutable_face() {
  return &face_;
}

// -------------------------------------------------------------------

// Camera

// required uint32 id = 1;
inline bool Camera::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Camera::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Camera::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Camera::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Camera::id() const {
  return id_;
}
inline void Camera::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required .nde.pb.Vector3f position = 2;
inline bool Camera::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Camera::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Camera::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Camera::clear_position() {
  if (position_ != NULL) position_->::nde::pb::Vector3f::Clear();
  clear_has_position();
}
inline const ::nde::pb::Vector3f& Camera::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::nde::pb::Vector3f* Camera::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::nde::pb::Vector3f;
  return position_;
}
inline ::nde::pb::Vector3f* Camera::release_position() {
  clear_has_position();
  ::nde::pb::Vector3f* temp = position_;
  position_ = NULL;
  return temp;
}

// required .nde.pb.Vector3f direction = 3;
inline bool Camera::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Camera::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Camera::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Camera::clear_direction() {
  if (direction_ != NULL) direction_->::nde::pb::Vector3f::Clear();
  clear_has_direction();
}
inline const ::nde::pb::Vector3f& Camera::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::nde::pb::Vector3f* Camera::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::nde::pb::Vector3f;
  return direction_;
}
inline ::nde::pb::Vector3f* Camera::release_direction() {
  clear_has_direction();
  ::nde::pb::Vector3f* temp = direction_;
  direction_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Color

// required uint32 id = 1;
inline bool Color::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Color::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Color::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Color::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Color::id() const {
  return id_;
}
inline void Color::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool Color::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Color::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Color::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Color::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Color::name() const {
  return *name_;
}
inline void Color::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Color::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Color::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Color::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Color::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float r = 3;
inline bool Color::has_r() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Color::set_has_r() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Color::clear_has_r() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Color::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline float Color::r() const {
  return r_;
}
inline void Color::set_r(float value) {
  set_has_r();
  r_ = value;
}

// required float g = 4;
inline bool Color::has_g() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Color::set_has_g() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Color::clear_has_g() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Color::clear_g() {
  g_ = 0;
  clear_has_g();
}
inline float Color::g() const {
  return g_;
}
inline void Color::set_g(float value) {
  set_has_g();
  g_ = value;
}

// required float b = 5;
inline bool Color::has_b() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Color::set_has_b() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Color::clear_has_b() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Color::clear_b() {
  b_ = 0;
  clear_has_b();
}
inline float Color::b() const {
  return b_;
}
inline void Color::set_b(float value) {
  set_has_b();
  b_ = value;
}

// optional float a = 6;
inline bool Color::has_a() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Color::set_has_a() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Color::clear_has_a() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Color::clear_a() {
  a_ = 0;
  clear_has_a();
}
inline float Color::a() const {
  return a_;
}
inline void Color::set_a(float value) {
  set_has_a();
  a_ = value;
}

// -------------------------------------------------------------------

// Assets

// repeated .nde.pb.Material material = 2;
inline int Assets::material_size() const {
  return material_.size();
}
inline void Assets::clear_material() {
  material_.Clear();
}
inline const ::nde::pb::Material& Assets::material(int index) const {
  return material_.Get(index);
}
inline ::nde::pb::Material* Assets::mutable_material(int index) {
  return material_.Mutable(index);
}
inline ::nde::pb::Material* Assets::add_material() {
  return material_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Material >&
Assets::material() const {
  return material_;
}
inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Material >*
Assets::mutable_material() {
  return &material_;
}

// repeated .nde.pb.UVMap uvmap = 3;
inline int Assets::uvmap_size() const {
  return uvmap_.size();
}
inline void Assets::clear_uvmap() {
  uvmap_.Clear();
}
inline const ::nde::pb::UVMap& Assets::uvmap(int index) const {
  return uvmap_.Get(index);
}
inline ::nde::pb::UVMap* Assets::mutable_uvmap(int index) {
  return uvmap_.Mutable(index);
}
inline ::nde::pb::UVMap* Assets::add_uvmap() {
  return uvmap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::UVMap >&
Assets::uvmap() const {
  return uvmap_;
}
inline ::google::protobuf::RepeatedPtrField< ::nde::pb::UVMap >*
Assets::mutable_uvmap() {
  return &uvmap_;
}

// repeated .nde.pb.Mesh mesh = 4;
inline int Assets::mesh_size() const {
  return mesh_.size();
}
inline void Assets::clear_mesh() {
  mesh_.Clear();
}
inline const ::nde::pb::Mesh& Assets::mesh(int index) const {
  return mesh_.Get(index);
}
inline ::nde::pb::Mesh* Assets::mutable_mesh(int index) {
  return mesh_.Mutable(index);
}
inline ::nde::pb::Mesh* Assets::add_mesh() {
  return mesh_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Mesh >&
Assets::mesh() const {
  return mesh_;
}
inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Mesh >*
Assets::mutable_mesh() {
  return &mesh_;
}

// repeated .nde.pb.Camera camera = 5;
inline int Assets::camera_size() const {
  return camera_.size();
}
inline void Assets::clear_camera() {
  camera_.Clear();
}
inline const ::nde::pb::Camera& Assets::camera(int index) const {
  return camera_.Get(index);
}
inline ::nde::pb::Camera* Assets::mutable_camera(int index) {
  return camera_.Mutable(index);
}
inline ::nde::pb::Camera* Assets::add_camera() {
  return camera_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Camera >&
Assets::camera() const {
  return camera_;
}
inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Camera >*
Assets::mutable_camera() {
  return &camera_;
}

// repeated .nde.pb.Color color = 6;
inline int Assets::color_size() const {
  return color_.size();
}
inline void Assets::clear_color() {
  color_.Clear();
}
inline const ::nde::pb::Color& Assets::color(int index) const {
  return color_.Get(index);
}
inline ::nde::pb::Color* Assets::mutable_color(int index) {
  return color_.Mutable(index);
}
inline ::nde::pb::Color* Assets::add_color() {
  return color_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nde::pb::Color >&
Assets::color() const {
  return color_;
}
inline ::google::protobuf::RepeatedPtrField< ::nde::pb::Color >*
Assets::mutable_color() {
  return &color_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace nde

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_src_2fresources_2fpb_2fresource_2eproto__INCLUDED
